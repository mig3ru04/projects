library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity pwm is
    Port (
        clk         : in  STD_LOGIC;         -- Reloj de 50 MHz
        rst         : in  STD_LOGIC;         -- Reset síncrono
        up_down     : in  STD_LOGIC;         -- '1' para aumentar, '0' para disminuir
        change_freq : in  STD_LOGIC;         -- Pulso para cambiar frecuencia
        out_freq    : out STD_LOGIC          -- Señal de salida con frecuencia ajustada
    );
end pwm;

architecture Behavioral of pwm is
    constant CLK_FREQ     : integer := 50000000;  -- 50 MHz
    constant MIN_FREQ     : integer := 1;         -- 1 Hz mínimo para evitar división por cero
    constant MAX_FREQ     : integer := 10000;     -- 10 kHz máximo

    signal freq_setting   : integer range MIN_FREQ to MAX_FREQ := 1000; -- Frecuencia inicial 1 kHz
    signal counter        : integer := 0;
    signal toggle         : STD_LOGIC := '0';
    signal clk_divider    : integer := CLK_FREQ / (2 * freq_setting);
begin

    -- Frecuencia ajustable
    process(clk)
    begin
        if rising_edge(clk) then
            if rst = '1' then
                freq_setting <= 1000;
            elsif change_freq = '1' then
                if up_down = '1' and freq_setting < MAX_FREQ then
                    freq_setting <= freq_setting + 1;
                elsif up_down = '0' and freq_setting > MIN_FREQ then
                    freq_setting <= freq_setting - 1;
                end if;
            end if;
        end if;
    end process;

    -- Señal de salida con frecuencia ajustada
    process(clk)
        variable clk_div_val : integer;
    begin
        if rising_edge(clk) then
            clk_div_val := CLK_FREQ / (2 * freq_setting);
            if counter >= clk_div_val then
                counter <= 0;
                toggle <= not toggle;
            else
                counter <= counter + 1;
            end if;
        end if;
    end process;

    out_freq <= toggle;
end Behavioral;
